---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
	</head>
	<body>
		<h1>Snake</h1>
		<canvas></canvas>
	</body>
</html>

<style>
	body{
		margin: 0;
		padding: 0;
		display: grid;
		place-content: center;
		min-height: 100vh;
	}
</style>


<script>
	const canvas = document.querySelector("canvas") as HTMLCanvasElement
	const context = canvas.getContext("2d") as CanvasRenderingContext2D

	type direction = "UP" | "DOWN" | "RIGHT" | "LEFT"
	type coordenates = {
		x: number
		y: number
	}
	
	const OPOSITE_DIRECTION = {
		DOWN: "UP",
		UP: "DOWN",
		RIGHT: "LEFT",
		LEFT: "RIGHT"
	}

	const INITIAL_STATE = {
		board: {
			width: 30,
			height: 30,
			pixel_size: 10,
		},
		goal: {
			x: 17,
			y: 12
		},
		snake : {
			body: [{x: 14, y: 0}, {x: 14, y: 1},],
			lastDirection: "UP" as direction,
			nextDirection: "DOWN" as direction
		}
	}

	let GAME_STATE = "PLAY"
	let BOARD = INITIAL_STATE.board
	let SNAKE= INITIAL_STATE.snake
	let GOAL = INITIAL_STATE.goal

	canvas.width = BOARD.pixel_size * BOARD.width
	canvas.height = BOARD.pixel_size * BOARD.height

	context.scale(BOARD.pixel_size, BOARD.pixel_size)

	function setGameOver(){
		GAME_STATE = "GAME_OVER"
		alert("GAME_OVER")
	}

	function drawBoard (){
		context.fillStyle = "#000"
		context.fillRect(0, 0, canvas.width, canvas.height)
	}

	function drawSnake (){
		context.fillStyle = "#fff"
		SNAKE.body.forEach(({x, y})=>{
			context.fillRect(x, y, 1, 1)
		})
	}

	function drawGoal() {
		context.fillStyle = "yellow"
		context.fillRect(GOAL.x, GOAL.y, 1, 1)
	}

	function leavesBoard(x: number, y:number){
		return x >= BOARD.width || y >= BOARD.width|| x < 0 || y < 0
	}

	function touchesSnakeBody({ x, y }: coordenates){
		return !!SNAKE.body.find(({x: x1, y: y1}) => x === x1 && y === y1)
	}

	function updateSnakeBody() {
		const snakeHead = SNAKE.body.slice(-1)
		const head = snakeHead[0]
		let nextMove: coordenates

		switch(SNAKE.nextDirection){
			case "RIGHT":
				leavesBoard(head.x + 1, head.y)
				? nextMove = {x: 0, y: head.y}
				: nextMove = {x: head.x + 1, y: head.y}
				break
			case "LEFT":
				leavesBoard(head.x - 1, head.y)
				? nextMove = {x: BOARD.width - 1, y: head.y}
				: nextMove = {x: head.x -1, y: head.y}
				break
			case "DOWN":
				leavesBoard(head.x, head.y + 1)
				? nextMove = {x: head.x, y: 0}
				: nextMove = {x: head.x, y: head.y + 1}
				break
			case "UP":
				leavesBoard(head.x, head.y - 1)
				? nextMove = {x: head.x, y: BOARD.height - 1}
				: nextMove = {x: head.x, y: head.y - 1}
				break
		}
		if (touchesSnakeBody(nextMove)){
			setGameOver()
		} else {
			SNAKE.lastDirection = SNAKE.nextDirection
			SNAKE.body = [...SNAKE.body, nextMove]
			if(nextMove.x === GOAL.x && nextMove.y === GOAL.y){
				GOAL = {
					x: Math.floor(Math.random() * BOARD.width),
					y: Math.floor(Math.random() * BOARD.height)
				}
			} else {
				SNAKE.body.shift()
			}
		}
	}

	function goesBack(direction: direction) {
		return OPOSITE_DIRECTION[direction] === SNAKE.lastDirection
	}

	window.addEventListener("keydown", (e)=>{
		e.preventDefault()
		switch(e.key){
			case "ArrowUp":
				return goesBack("UP") ? null : SNAKE.nextDirection = "UP"
			case "ArrowDown":
				return goesBack("DOWN") ? null : SNAKE.nextDirection = "DOWN"
			case "ArrowRight":
				return goesBack("RIGHT") ? null : SNAKE.nextDirection = "RIGHT"
			case "ArrowLeft":
				return goesBack("LEFT") ? null : SNAKE.nextDirection = "LEFT"
					
		}
	})
	
	function update() {
		switch(GAME_STATE){
			case "PLAY":{
				updateSnakeBody()
				drawBoard()
				drawSnake()
				drawGoal()
				break
			}
			case "GAME_OVER":{
				return
			}
		}
		setTimeout(() => {
			window.requestAnimationFrame(update)
		}, 1000 / 30);
	}

	update()
</script>